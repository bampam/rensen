use std::fs::{self, File};
use std::io::{self, Read, Error as IOError};
use std::net::TcpStream;
use ssh2::{Session, Error as SSHError};
use std::path::{Path, PathBuf};
use crate::logging::{log_error, ErrorType};
use crate::serde;

fn connect_ssh(identifier: &str, port: u16) -> Result<Session, ErrorType> {
    // Connect to SSH server
    let tcp = TcpStream::connect(format!("{}:{}", identifier, port)).map_err(|err| {
        log_error(ErrorType::Connect, format!("Could not connect to host: {}", err).as_str());
        ErrorType::Connect
    })?;

    // Create SSH session
    let mut sess = Session::new().map_err(|err| {
        log_error(ErrorType::Session, format!("Could not create SSH session: {}", err).as_str());
        ErrorType::Session
    })?;

    // Perform SSH handshake
    sess.set_tcp_stream(tcp);
    sess.handshake().map_err(|err| {
        log_error(ErrorType::Handshake, format!("Could not perform SSH handshake: {}", err).as_str());
        ErrorType::Handshake
    })?;

    Ok(sess)
}

fn copy_remote_directory(sess: &mut Session, remote_path: &Path, destination_path: &Path) -> Result<(), ErrorType> {
    // Create destination directory if it doesn't exist
    if !destination_path.exists() {
        fs::create_dir_all(destination_path).map_err(|err| {
            log_error(ErrorType::STD, format!("Error creating directory: {}", err).as_str());
            ErrorType::STD
        })?;
    }

    let mut channel = sess.scp_recv(remote_path).map_err(|err| {
        log_error(ErrorType::Copy, format!("Could not receive files from remote directory: {}", err).as_str());
        ErrorType::Copy
    })?;

    let mut buffer: Vec<u8> = Vec::new();
    loop {
        match channel
            _=> (),
        }
    }

    Ok(())
}

// use in recursing directory
fn copy_remote_file(sess: &mut Session, remote_path: &Path, destination_path: &Path) -> Result<(), ErrorType> {


    Ok(())
}

pub fn backup_rsync(host: &mut serde::Host) -> Result<(), ErrorType> {
    // ext ip or hostname
    let identifier = match &host.identifier {
        serde::HostIdentifier::Ip(ip) => ip,
        serde::HostIdentifier::Hostname(hostname) => hostname,
    };

    // ext port
    let port = host.port.unwrap_or(22);
    let mut sess = connect_ssh(&identifier, port)?;

    // read key
    let private_key_path = host.key_path.as_ref().map_or("/", |s| s.to_str().unwrap_or("/"));
    let mut private_key = String::new();
    File::open(private_key_path).map_err(|err| {
        log_error(ErrorType::KeyLoad, format!("Could not read private key file: {}", err).as_str());
        ErrorType::KeyLoad
    })?.read_to_string(&mut private_key).map_err(|err| {
        log_error(ErrorType::KeyLoad, format!("Could not load private key file: {}", err).as_str());
        ErrorType::KeyLoad
    })?;

    // Authenticate with public key
    sess.userauth_pubkey_file(&host.user, None, Path::new("/"), Some(&private_key)).map_err(|err| {
        log_error(ErrorType::Auth, format!("Could not authenticate with private key: {}", err).as_str());
        ErrorType::Auth
    })?;

    copy_remote_directory(&mut sess, &host.remote_path, &host.destination_path)?;
    
    Ok(())
}


