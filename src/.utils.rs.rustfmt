use std::fs::{self, File};
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use zip::write::FileOptions;
use zip::ZipWriter;
use std::os::unix::fs::PermissionsExt;

use crate::logging;

fn zip_dir(path: &str) -> std::io::Result<()> {

    let file = File::create(path)?;
    let mut zip_writer = ZipWriter::new(file);

    for entry in fs::read_dir(path)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            continue;
        }

        let rel_path = match path.strip_prefix(Path::new(&path)) {
            Ok(relative_path) => relative_path,
            Err(_) => {
                logging::log_error(logging::Error::Zip("Could not get relative path".to_string()));
                &Path::new("") 
            }
        };

       let options = FileOptions::default()
            .compression_method(zip::CompressionMethod::Stored)
            .unix_permissions(entry.metadata()?.permissions().mode());
        zip_writer.start_file(rel_path.to_str().unwrap_or_else(|| {
            logging::log_error(logging::Error("error converting string".to_string()))})
     ,options)?;
        let mut file = File::open(&path)?;
        io::copy(&mut file, &mut zip_writer)?;
    };

    Ok(())
}

